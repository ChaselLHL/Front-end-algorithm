# 时间复杂度分析

实际指的是每条语句的执行次数之和

时间复杂度取n的最高次幂来表示

## O(1)

常数级别的复杂度

代码中的所有表达式与n无关

## O(n)

只有一层循环

function Fn(n) {

​	let i = 0;

​	for(; i < n; i ++) {

​		console.log(n)

​	}

}

所有语句的执行次数之和： 1 +  n + n = 2n + 1

取最高次幂并忽略常数项，时间复杂度为 O(n)

## O(n2)

以此类推，说明执行次数最多的语句执行了 n 的平方次，

也就是两层嵌套的循环 ,  最内层的循环语句 执行了 n * n 次



## O(logn)

看下面的代码

```(js)
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

分析时间复杂度就看执行次数最多的语句

很显然，就是循环里的  i = i * 2;

这条语句执行了多少次呢？

可以理解为 i 要乘  多少次  2 才会大于n

其中的多少次就是我们的时间复杂度

那么计算公式就是：

​	 i  乘 以 2的 x 次方 等于 n

x = log2 (n / i)

i 是一个常数，去掉

x = log2 n

时间复杂度就是 O(log2 n)

如果代码变为

```js
 i=1;
 while (i <= n)  {
   i = i * 3;
 }
```

时间复杂度就是 O(log3 n)

log3n 就等于 log3 2 * log2 n，

所以 O(log3n) = O(C * log2n)，其中 C=log32 是一个常量可以忽略

我们可以认为  O(log3n) = O(log2n)

所以不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。

# 空间复杂度

记录的是运行代码消耗的内存和n的关系

同样是取n的最高次幂

```js

function  fn (int n) {
  let i = 0;
  const a = new Array(n);
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    console.log(i);
  }
}
```

代码中 的内存消耗一般是在给变量赋值时

可以看到 函数  const a = new Array(n);  初始化了a ， 并且 给a 赋值了 一个 长度为 n 的数组

后续的循环中虽然修改了数组中的值，但是数组的长度并没有改变

所以**空间 复杂度 还是 O(n)**

结合以上所学，我们可以判断出 时间复杂度是 1 +  1 + n + n + n -1 + n - 1 = 4n

忽略常数项，**时间复杂度为 O(n)**



# 当前等级5

获取武器： 石锤



