对于不稳定的时间复杂度

什么是不稳定，

就是函数参数的变化会导致函数有不同的时间复杂度

一般出现在有条件语句的循环中

基于此引出了四个概念

+ 最好情况时间复杂度（best case time complexity）
+ 最坏情况时间复杂度（worst case time complexity）
+ 平均情况时间复杂度（average case time complexity）
+ 均摊时间复杂度（amortized time complexity）

以下分析基于这段代码

```js
function fn(arr, n, target) {
  let i = 0;
  let pos = -1;
  for(;i < n; i++) {
    if (arr[i] === target) {
      pos = i;
      break;
    }
  }
  return pos;
}
```

#  最好情况时间复杂度

就是最好情况下的时间复杂度

上面那段代码中最好的的情况就是 i = 0 的时候 a r r[i] === target

此时循环体内的语句只执行了一次

所以最好情况时间复杂度为O(1) 

# 最坏情况时间复杂度

那么最坏的情况是什么

就是 a r r 数组中 没有 等于 target 的值

此时 循环体中的语句执行了 n 次

所以 最坏情况时间复杂度 为 O(n)

# 平均情况时间复杂度

那怎么计算这段代码的平均情况时间复杂度呢

先看有几种情况

target可能存在于数组的索引 0， 1， 2， 3 .... n - 1 中

或者不存在数组中

所以所有的可能情况为 n + 1

每种情况下的复杂度相加   除以  n + 1 就是平均复杂度

(1 + 2 + ...... + n + n) / (n + 1) = n(n + 2) / 2(n + 1)

计算简化后再去掉常数项，取最高次幂可以得出平均复杂度为O(n)

这个计算方法有点问题, 由于每种情况的概率是不一样的，不能直接相加

假设 target 存在数组中与不存在数组中的概率分别为 1/ 2

存在数组中每个索引的概率为 1/n

所以 

 1 * 1/2n + 2 * 1/2n + ...... + n * 1/2n + n * 1/2

=  (n + 1) / 4 + n / 2

 = (3n + 1) / 4

去掉常数项，取最高次幂可以得出平均复杂度还是O(n)

概率论中该值叫加权平均值，也叫期望值

所以平均时间复杂度的全称应该叫**加权平均时间复杂度**或者**期望时间复杂度**

# 均摊时间复杂度

摊还分析法，把复杂度高的情况均摊到复杂度小的情况

看这个例子

```js

 // array表示一个长度为n的数组
 // 代码中的array.length就等于n
 let array = new Array(n);
 let count = 0;
 
 function insert(val) {
    if (count == array.length) {
       let sum = 0;
       for (let  i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```

这个插入方法，

count 小于 数组的长度， 时间复杂度为O(1)

count 等于 数组的长度， 时间复杂度为O(n)

用前面学过的平均时间复杂度计算方法

1 *  1/ (n + 1) +  1* 1/(n + 1) + ...... + 1* 1/(n + 1) + n * 1/(n + 1)

= (n - 1) / (n + 1) + n /(n + 1)

 =   (2n - 1) / (n + 1)

由于分子分母的n的最高次幂是一样的所以时间复杂度为 O(1)



用均摊的思想，把最后一个复杂度为O(n) 的情况均摊给前 n - 1个复杂度为O(1) 的情况

每种情况均摊到的复杂度约等于1， 1 + 1 = 2

所以这一组操作的均摊时间复杂度为O(1)



