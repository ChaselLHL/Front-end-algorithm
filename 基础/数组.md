数组看起来很简单

你是否真的了解数组这种数据结构

# 数组的关键概念：

1. 一组连续的内存空间，相同的数据类型

   1. 注意js中没有类型约束，不同类型间会发生隐式类型转换，所以js的数组中可以存不同类型的数据

   2. 因为内存空间连续，所以数组可以实现**通过下标随机访问**

   3. 如何通过下标访问的呢，根据如下寻址公式

      ```js
      // base_address 代表数组内存块的首地址
      // data_type_size 表示数组中每个元素的大小
      a[i]_address = base_address + i * data_type_size
      ```

   4. 由此可见，如果js 的数组内存的元素类型不一样的话可能会导致寻址变慢

   5. 但也是因为内存空间连续，数组的插入，删除操作为了保证内存空间的连续，需要做数据移动的工作

2. 线性表（Linear List）

   1. 线性表上的数据只有向前和向后两个方向
   2. 同为线性表的数据结构还有 链表、队列、栈
   3. 与它对立的结构为非线性表（数据之间不是简单的前后关系）
   4. j s 中 并没有封装 链表、队列、栈 这些数据结构，我们可以自己实现（后面细说）

# 低效的插入，删除操作

Js 的 splice api 可以方便的对数组元素进行插入和删除

那么splice 内部做了什么

## 插入

假设有一个长度为n的数组，要在第k个位置插入一个元素， 我们需要把第k个位置空出来

如果数组是有序的，就需要把原数组的k到n-1的所有元素向后移一位

分析得出平均时间复杂度为O(n)

如果数组是无序的， 就可以把第k位的元素挪到最后，再把要插入的元素放到第k位

此时时间复杂度为O(1)

## 删除

假设有一个长度为n的数组，要删除第k个位置的元素，为了保证数组空间的连续性

需要把第 k 到 n - 1位的数据向前移一位

平均时间复杂度为O(n)

### 优化方法

删除时标记删除的位置，并不移动元素

直到数组空间不够时再触发一次真正的删除操作



# 数组越界

上手就是j s的同学可能没有数组越界的概念

因为就算越界了，j s 的 数组会自动扩容，并不会出问题

j s 的 数组相当于对数组的细节进行了一层封装，相当于一个**容器**

看这段代码

```js
function test() {
    const arr = new Array(3).fill(1);
    for(let i = 0; i <= 3; i ++) {
        arr[i] = 0;
        console.log('zi ding yi')
    }
    return arr;
}

console.log(test());
// 打印结果
zi ding yi
zi ding yi
zi ding yi
zi ding yi
```

但如果相同的代码运行在c++中

```c++

int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("zi ding yi\n");
    }
    return 0;
}
// 结果
无限打印 zi ding yi
```

为什么会这样呢，

因为在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的

根据寻址公式，当 arr[3] = 0  时寻址寻到的内存地址并不属于arr

而是变量i的存储地址，所以相当于 i = 0, 造成死循环

**c++也提供了相当于容器类, STL 中的 vector**

相同的代码运行在JVM中，会抛出java.lang.ArrayIndexOutOfBoundsException

**Java 中的 ArrayList 为容器类**

虽然容器可以动态扩容并暴露出了一些插入删除的api, 但容器的底层还是会去做元素搬运的工作

所以如果可以预先确定容器的最大值，最好预设容器的长度

# 结论

业务中一般使用容器开发，

如果特别在意性能的话使用数组开发，

话说回来js中的数组好像默认就是容器......







